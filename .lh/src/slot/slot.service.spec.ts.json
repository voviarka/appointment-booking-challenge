{
    "sourceFile": "src/slot/slot.service.spec.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 13,
            "patches": [
                {
                    "date": 1740690870910,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740692628848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,224 +1,1 @@\n-import { Test, TestingModule } from '@nestjs/testing';\n-import { SlotService } from './slot.service';\n-import { getRepositoryToken } from '@nestjs/typeorm';\n-import { Slot } from './entities/slot.entity';\n-import { Repository } from 'typeorm';\n-import { NotFoundException, BadRequestException } from '@nestjs/common';\n-import { CreateSlotDto } from './dto/create-slot.dto';\n-import { UpdateSlotDto } from './dto/update-slot.dto';\n \n-describe('SlotService', () => {\n-  let service: SlotService;\n-  let repository: Repository<Slot>;\n-\n-  const mockSlotRepository = {\n-    create: jest.fn(),\n-    save: jest.fn(),\n-    find: jest.fn(),\n-    findOne: jest.fn(),\n-    update: jest.fn(),\n-    delete: jest.fn(),\n-    createQueryBuilder: jest.fn(() => ({\n-      where: jest.fn().mockReturnThis(),\n-      andWhere: jest.fn().mockReturnThis(),\n-      getMany: jest.fn(),\n-    })),\n-  };\n-\n-  beforeEach(async () => {\n-    const module: TestingModule = await Test.createTestingModule({\n-      providers: [\n-        SlotService,\n-        {\n-          provide: getRepositoryToken(Slot),\n-          useValue: mockSlotRepository,\n-        },\n-      ],\n-    }).compile();\n-\n-    service = module.get<SlotService>(SlotService);\n-    repository = module.get<Repository<Slot>>(getRepositoryToken(Slot));\n-    \n-    jest.clearAllMocks();\n-  });\n-\n-  it('should be defined', () => {\n-    expect(service).toBeDefined();\n-  });\n-\n-  describe('create', () => {\n-    it('should create a new slot successfully', async () => {\n-      const createSlotDto: CreateSlotDto = {\n-        startTime: new Date('2023-01-01T09:00:00Z'),\n-        endTime: new Date('2023-01-01T10:00:00Z'),\n-        isBooked: false,\n-      };\n-      \n-      const newSlot = { id: 1, ...createSlotDto };\n-      \n-      mockSlotRepository.create.mockReturnValue(newSlot);\n-      mockSlotRepository.save.mockResolvedValue(newSlot);\n-      \n-      const result = await service.create(createSlotDto);\n-      \n-      expect(mockSlotRepository.create).toHaveBeenCalledWith(createSlotDto);\n-      expect(mockSlotRepository.save).toHaveBeenCalledWith(newSlot);\n-      expect(result).toEqual(newSlot);\n-    });\n-\n-    it('should throw BadRequestException if end time is before start time', async () => {\n-      const createSlotDto: CreateSlotDto = {\n-        startTime: new Date('2023-01-01T10:00:00Z'),\n-        endTime: new Date('2023-01-01T09:00:00Z'),\n-        isBooked: false,\n-      };\n-      \n-      await expect(service.create(createSlotDto)).rejects.toThrow(BadRequestException);\n-    });\n-\n-    it('should throw BadRequestException if slot duration is invalid', async () => {\n-      const createSlotDto: CreateSlotDto = {\n-        startTime: new Date('2023-01-01T09:00:00Z'),\n-        endTime: new Date('2023-01-01T09:15:00Z'), // Assuming minimum duration is 30 minutes\n-        isBooked: false,\n-      };\n-      \n-      await expect(service.create(createSlotDto)).rejects.toThrow(BadRequestException);\n-    });\n-  });\n-\n-  describe('findAll', () => {\n-    it('should return an array of slots', async () => {\n-      const slots = [\n-        { id: 1, startTime: new Date(), endTime: new Date(), isBooked: false },\n-        { id: 2, startTime: new Date(), endTime: new Date(), isBooked: true },\n-      ];\n-      \n-      mockSlotRepository.find.mockResolvedValue(slots);\n-      \n-      const result = await service.findAll();\n-      \n-      expect(mockSlotRepository.find).toHaveBeenCalled();\n-      expect(result).toEqual(slots);\n-    });\n-  });\n-\n-  describe('findAvailable', () => {\n-    it('should return available slots for a given date range', async () => {\n-      const startDate = new Date('2023-01-01');\n-      const endDate = new Date('2023-01-02');\n-      \n-      const availableSlots = [\n-        { id: 1, startTime: new Date('2023-01-01T09:00:00Z'), endTime: new Date('2023-01-01T10:00:00Z'), isBooked: false },\n-        { id: 2, startTime: new Date('2023-01-01T14:00:00Z'), endTime: new Date('2023-01-01T15:00:00Z'), isBooked: false },\n-      ];\n-      \n-      const queryBuilder = mockSlotRepository.createQueryBuilder();\n-      queryBuilder.getMany.mockResolvedValue(availableSlots);\n-      \n-      const result = await service.findAvailable(startDate, endDate);\n-      \n-      expect(mockSlotRepository.createQueryBuilder).toHaveBeenCalled();\n-      expect(queryBuilder.where).toHaveBeenCalledWith('slot.startTime >= :startDate', { startDate });\n-      expect(queryBuilder.andWhere).toHaveBeenCalledWith('slot.endTime <= :endDate', { endDate });\n-      expect(queryBuilder.andWhere).toHaveBeenCalledWith('slot.isBooked = :isBooked', { isBooked: false });\n-      expect(result).toEqual(availableSlots);\n-    });\n-  });\n-\n-  describe('findOne', () => {\n-    it('should return a slot by id', async () => {\n-      const id = 1;\n-      const slot = { id, startTime: new Date(), endTime: new Date(), isBooked: false };\n-      \n-      mockSlotRepository.findOne.mockResolvedValue(slot);\n-      \n-      const result = await service.findOne(id);\n-      \n-      expect(mockSlotRepository.findOne).toHaveBeenCalledWith({ where: { id } });\n-      expect(result).toEqual(slot);\n-    });\n-\n-    it('should throw NotFoundException if slot is not found', async () => {\n-      const id = 999;\n-      \n-      mockSlotRepository.findOne.mockResolvedValue(null);\n-      \n-      await expect(service.findOne(id)).rejects.toThrow(NotFoundException);\n-    });\n-  });\n-\n-  describe('update', () => {\n-    it('should update a slot successfully', async () => {\n-      const id = 1;\n-      const updateSlotDto: UpdateSlotDto = { isBooked: true };\n-      const existingSlot = { \n-        id, \n-        startTime: new Date('2023-01-01T09:00:00Z'), \n-        endTime: new Date('2023-01-01T10:00:00Z'), \n-        isBooked: false \n-      };\n-      const updatedSlot = { ...existingSlot, ...updateSlotDto };\n-      \n-      mockSlotRepository.findOne.mockResolvedValue(existingSlot);\n-      mockSlotRepository.update.mockResolvedValue({ affected: 1 });\n-      mockSlotRepository.findOne.mockResolvedValueOnce(existingSlot).mockResolvedValueOnce(updatedSlot);\n-      \n-      const result = await service.update(id, updateSlotDto);\n-      \n-      expect(mockSlotRepository.findOne).toHaveBeenCalledWith({ where: { id } });\n-      expect(mockSlotRepository.update).toHaveBeenCalledWith(id, updateSlotDto);\n-      expect(result).toEqual(updatedSlot);\n-    });\n-\n-    it('should throw NotFoundException if slot to update is not found', async () => {\n-      const id = 999;\n-      const updateSlotDto: UpdateSlotDto = { isBooked: true };\n-      \n-      mockSlotRepository.findOne.mockResolvedValue(null);\n-      \n-      await expect(service.update(id, updateSlotDto)).rejects.toThrow(NotFoundException);\n-    });\n-\n-    it('should throw BadRequestException if trying to update with invalid time range', async () => {\n-      const id = 1;\n-      const existingSlot = { \n-        id, \n-        startTime: new Date('2023-01-01T09:00:00Z'), \n-        endTime: new Date('2023-01-01T10:00:00Z'), \n-        isBooked: false \n-      };\n-      const updateSlotDto: UpdateSlotDto = { \n-        startTime: new Date('2023-01-01T11:00:00Z'),\n-        endTime: new Date('2023-01-01T10:00:00Z')\n-      };\n-      \n-      mockSlotRepository.findOne.mockResolvedValue(existingSlot);\n-      \n-      await expect(service.update(id, updateSlotDto)).rejects.toThrow(BadRequestException);\n-    });\n-  });\n-\n-  describe('remove', () => {\n-    it('should remove a slot successfully', async () => {\n-      const id = 1;\n-      const slot = { id, startTime: new Date(), endTime: new Date(), isBooked: false };\n-      \n-      mockSlotRepository.findOne.mockResolvedValue(slot);\n-      mockSlotRepository.delete.mockResolvedValue({ affected: 1 });\n-      \n-      await service.remove(id);\n-      \n-      expect(mockSlotRepository.findOne).toHaveBeenCalledWith({ where: { id } });\n-      expect(mockSlotRepository.delete).toHaveBeenCalledWith(id);\n-    });\n-\n-    it('should throw NotFoundException if slot to remove is not found', async () => {\n-      const id = 999;\n-      \n-      mockSlotRepository.findOne.mockResolvedValue(null);\n-      \n-      await expect(service.remove(id)).rejects.toThrow(NotFoundException);\n-    });\n-  });\n-});\n"
                },
                {
                    "date": 1740692714927,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,258 @@\n+import { Test, TestingModule } from '@nestjs/testing';\n+import { SlotService } from './slot.service';\n+import { PrismaService } from '../prisma/prisma.service';\n+import { NotFoundException, BadRequestException } from '@nestjs/common';\n+import { CreateSlotDto } from './dto/create-slot.dto';\n+import { UpdateSlotDto } from './dto/update-slot.dto';\n \n+describe('SlotService', () => {\n+  let service: SlotService;\n+  let prisma: PrismaService;\n+\n+  const mockPrismaService = {\n+    slot: {\n+      create: jest.fn(),\n+      findMany: jest.fn(),\n+      findUnique: jest.fn(),\n+      update: jest.fn(),\n+      delete: jest.fn(),\n+    },\n+  };\n+\n+  beforeEach(async () => {\n+    const module: TestingModule = await Test.createTestingModule({\n+      providers: [\n+        SlotService,\n+        {\n+          provide: PrismaService,\n+          useValue: mockPrismaService,\n+        },\n+      ],\n+    }).compile();\n+\n+    service = module.get<SlotService>(SlotService);\n+    prisma = module.get<PrismaService>(PrismaService);\n+    \n+    jest.clearAllMocks();\n+  });\n+\n+  it('should be defined', () => {\n+    expect(service).toBeDefined();\n+  });\n+\n+  describe('create', () => {\n+    it('should create a new slot successfully', async () => {\n+      const createSlotDto: CreateSlotDto = {\n+        startTime: new Date('2023-01-01T09:00:00Z'),\n+        endTime: new Date('2023-01-01T10:00:00Z'),\n+        isBooked: false,\n+      };\n+      \n+      const newSlot = { id: 1, ...createSlotDto };\n+      \n+      mockPrismaService.slot.create.mockResolvedValue(newSlot);\n+      \n+      const result = await service.create(createSlotDto);\n+      \n+      expect(mockPrismaService.slot.create).toHaveBeenCalledWith({\n+        data: createSlotDto,\n+      });\n+      expect(result).toEqual(newSlot);\n+    });\n+\n+    it('should throw BadRequestException if end time is before start time', async () => {\n+      const createSlotDto: CreateSlotDto = {\n+        startTime: new Date('2023-01-01T10:00:00Z'),\n+        endTime: new Date('2023-01-01T09:00:00Z'),\n+        isBooked: false,\n+      };\n+      \n+      await expect(service.create(createSlotDto)).rejects.toThrow(BadRequestException);\n+    });\n+\n+    it('should throw BadRequestException if slot duration is invalid', async () => {\n+      const createSlotDto: CreateSlotDto = {\n+        startTime: new Date('2023-01-01T09:00:00Z'),\n+        endTime: new Date('2023-01-01T09:15:00Z'), // Assuming minimum duration is 30 minutes\n+        isBooked: false,\n+      };\n+      \n+      await expect(service.create(createSlotDto)).rejects.toThrow(BadRequestException);\n+    });\n+  });\n+\n+  describe('findAll', () => {\n+    it('should return an array of slots', async () => {\n+      const slots = [\n+        { id: 1, startTime: new Date(), endTime: new Date(), isBooked: false },\n+        { id: 2, startTime: new Date(), endTime: new Date(), isBooked: true },\n+      ];\n+      \n+      mockPrismaService.slot.findMany.mockResolvedValue(slots);\n+      \n+      const result = await service.findAll();\n+      \n+      expect(mockPrismaService.slot.findMany).toHaveBeenCalled();\n+      expect(result).toEqual(slots);\n+    });\n+  });\n+\n+  describe('findAvailable', () => {\n+    it('should return available slots for a given date range', async () => {\n+      const startDate = new Date('2023-01-01');\n+      const endDate = new Date('2023-01-02');\n+      \n+      const availableSlots = [\n+        { id: 1, startTime: new Date('2023-01-01T09:00:00Z'), endTime: new Date('2023-01-01T10:00:00Z'), isBooked: false },\n+        { id: 2, startTime: new Date('2023-01-01T14:00:00Z'), endTime: new Date('2023-01-01T15:00:00Z'), isBooked: false },\n+      ];\n+      \n+      mockPrismaService.slot.findMany.mockResolvedValue(availableSlots);\n+      \n+      const result = await service.findAvailable(startDate, endDate);\n+      \n+      expect(mockPrismaService.slot.findMany).toHaveBeenCalledWith({\n+        where: {\n+          startTime: { gte: startDate },\n+          endTime: { lte: endDate },\n+          isBooked: false,\n+        },\n+      });\n+      expect(result).toEqual(availableSlots);\n+    });\n+  });\n+\n+  describe('findOne', () => {\n+    it('should return a slot by id', async () => {\n+      const id = 1;\n+      const slot = { id, startTime: new Date(), endTime: new Date(), isBooked: false };\n+      \n+      mockPrismaService.slot.findUnique.mockResolvedValue(slot);\n+      \n+      const result = await service.findOne(id);\n+      \n+      expect(mockPrismaService.slot.findUnique).toHaveBeenCalledWith({\n+        where: { id },\n+      });\n+      expect(result).toEqual(slot);\n+    });\n+\n+    it('should throw NotFoundException if slot is not found', async () => {\n+      const id = 999;\n+      \n+      mockPrismaService.slot.findUnique.mockResolvedValue(null);\n+      \n+      await expect(service.findOne(id)).rejects.toThrow(NotFoundException);\n+    });\n+  });\n+\n+  describe('update', () => {\n+    it('should update a slot successfully', async () => {\n+      const id = 1;\n+      const updateSlotDto: UpdateSlotDto = { isBooked: true };\n+      const existingSlot = { \n+        id, \n+        startTime: new Date('2023-01-01T09:00:00Z'), \n+        endTime: new Date('2023-01-01T10:00:00Z'), \n+        isBooked: false \n+      };\n+      const updatedSlot = { ...existingSlot, ...updateSlotDto };\n+      \n+      mockPrismaService.slot.findUnique.mockResolvedValue(existingSlot);\n+      mockPrismaService.slot.update.mockResolvedValue(updatedSlot);\n+      \n+      const result = await service.update(id, updateSlotDto);\n+      \n+      expect(mockPrismaService.slot.findUnique).toHaveBeenCalledWith({\n+        where: { id },\n+      });\n+      expect(mockPrismaService.slot.update).toHaveBeenCalledWith({\n+        where: { id },\n+        data: updateSlotDto,\n+      });\n+      expect(result).toEqual(updatedSlot);\n+    });\n+\n+    it('should throw NotFoundException if slot to update is not found', async () => {\n+      const id = 999;\n+      const updateSlotDto: UpdateSlotDto = { isBooked: true };\n+      \n+      mockPrismaService.slot.findUnique.mockResolvedValue(null);\n+      \n+      await expect(service.update(id, updateSlotDto)).rejects.toThrow(NotFoundException);\n+    });\n+\n+    it('should throw BadRequestException if trying to update with invalid time range', async () => {\n+      const id = 1;\n+      const existingSlot = { \n+        id, \n+        startTime: new Date('2023-01-01T09:00:00Z'), \n+        endTime: new Date('2023-01-01T10:00:00Z'), \n+        isBooked: false \n+      };\n+      const updateSlotDto: UpdateSlotDto = { \n+        startTime: new Date('2023-01-01T11:00:00Z'),\n+        endTime: new Date('2023-01-01T10:00:00Z')\n+      };\n+      \n+      mockPrismaService.slot.findUnique.mockResolvedValue(existingSlot);\n+      \n+      await expect(service.update(id, updateSlotDto)).rejects.toThrow(BadRequestException);\n+    });\n+  });\n+\n+  describe('remove', () => {\n+    it('should remove a slot successfully', async () => {\n+      const id = 1;\n+      const slot = { id, startTime: new Date(), endTime: new Date(), isBooked: false };\n+      \n+      mockPrismaService.slot.findUnique.mockResolvedValue(slot);\n+      mockPrismaService.slot.delete.mockResolvedValue(slot);\n+      \n+      await service.remove(id);\n+      \n+      expect(mockPrismaService.slot.findUnique).toHaveBeenCalledWith({\n+        where: { id },\n+      });\n+      expect(mockPrismaService.slot.delete).toHaveBeenCalledWith({\n+        where: { id },\n+      });\n+    });\n+\n+    it('should throw NotFoundException if slot to remove is not found', async () => {\n+      const id = 999;\n+      \n+      mockPrismaService.slot.findUnique.mockResolvedValue(null);\n+      \n+      await expect(service.remove(id)).rejects.toThrow(NotFoundException);\n+    });\n+  });\n+\n+  describe('findBookedSlots', () => {\n+    it('should return booked slots for a given user', async () => {\n+      const userId = 3;\n+      \n+      const bookedSlots = [\n+        { \n+          id: 1, \n+          sales_manager_id: 104,\n+          start_date: new Date('2024-05-03T10:30:00.000Z'),\n+          end_date: new Date('2024-05-03T11:00:00.000Z'),\n+          user_id: userId\n+        }\n+      ];\n+      \n+      mockPrismaService.slot.findMany.mockResolvedValue(bookedSlots);\n+      \n+      const result = await service.findBookedSlots(userId);\n+      \n+      expect(mockPrismaService.slot.findMany).toHaveBeenCalledWith({\n+        where: {\n+          user_id: userId,\n+          isBooked: true,\n+        },\n+      });\n+      expect(result).toEqual(bookedSlots);\n+    });\n+  });\n+});\n"
                },
                {
                    "date": 1740695098881,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,258 +1,11 @@\n import { Test, TestingModule } from '@nestjs/testing';\n import { SlotService } from './slot.service';\n-import { PrismaService } from '../prisma/prisma.service';\n+import { PrismaService } from '../common/prisma/prisma.service';\n import { NotFoundException, BadRequestException } from '@nestjs/common';\n-import { CreateSlotDto } from './dto/create-slot.dto';\n-import { UpdateSlotDto } from './dto/update-slot.dto';\n+import { BookedSlotDto } from './dto/booked-slot.dto';\n+import { SlotBookingsDto } from './dto/slot-bookings.dto';\n \n describe('SlotService', () => {\n   let service: SlotService;\n   let prisma: PrismaService;\n \n-  const mockPrismaService = {\n-    slot: {\n-      create: jest.fn(),\n-      findMany: jest.fn(),\n-      findUnique: jest.fn(),\n-      update: jest.fn(),\n-      delete: jest.fn(),\n-    },\n-  };\n-\n-  beforeEach(async () => {\n-    const module: TestingModule = await Test.createTestingModule({\n-      providers: [\n-        SlotService,\n-        {\n-          provide: PrismaService,\n-          useValue: mockPrismaService,\n-        },\n-      ],\n-    }).compile();\n-\n-    service = module.get<SlotService>(SlotService);\n-    prisma = module.get<PrismaService>(PrismaService);\n-    \n-    jest.clearAllMocks();\n-  });\n-\n-  it('should be defined', () => {\n-    expect(service).toBeDefined();\n-  });\n-\n-  describe('create', () => {\n-    it('should create a new slot successfully', async () => {\n-      const createSlotDto: CreateSlotDto = {\n-        startTime: new Date('2023-01-01T09:00:00Z'),\n-        endTime: new Date('2023-01-01T10:00:00Z'),\n-        isBooked: false,\n-      };\n-      \n-      const newSlot = { id: 1, ...createSlotDto };\n-      \n-      mockPrismaService.slot.create.mockResolvedValue(newSlot);\n-      \n-      const result = await service.create(createSlotDto);\n-      \n-      expect(mockPrismaService.slot.create).toHaveBeenCalledWith({\n-        data: createSlotDto,\n-      });\n-      expect(result).toEqual(newSlot);\n-    });\n-\n-    it('should throw BadRequestException if end time is before start time', async () => {\n-      const createSlotDto: CreateSlotDto = {\n-        startTime: new Date('2023-01-01T10:00:00Z'),\n-        endTime: new Date('2023-01-01T09:00:00Z'),\n-        isBooked: false,\n-      };\n-      \n-      await expect(service.create(createSlotDto)).rejects.toThrow(BadRequestException);\n-    });\n-\n-    it('should throw BadRequestException if slot duration is invalid', async () => {\n-      const createSlotDto: CreateSlotDto = {\n-        startTime: new Date('2023-01-01T09:00:00Z'),\n-        endTime: new Date('2023-01-01T09:15:00Z'), // Assuming minimum duration is 30 minutes\n-        isBooked: false,\n-      };\n-      \n-      await expect(service.create(createSlotDto)).rejects.toThrow(BadRequestException);\n-    });\n-  });\n-\n-  describe('findAll', () => {\n-    it('should return an array of slots', async () => {\n-      const slots = [\n-        { id: 1, startTime: new Date(), endTime: new Date(), isBooked: false },\n-        { id: 2, startTime: new Date(), endTime: new Date(), isBooked: true },\n-      ];\n-      \n-      mockPrismaService.slot.findMany.mockResolvedValue(slots);\n-      \n-      const result = await service.findAll();\n-      \n-      expect(mockPrismaService.slot.findMany).toHaveBeenCalled();\n-      expect(result).toEqual(slots);\n-    });\n-  });\n-\n-  describe('findAvailable', () => {\n-    it('should return available slots for a given date range', async () => {\n-      const startDate = new Date('2023-01-01');\n-      const endDate = new Date('2023-01-02');\n-      \n-      const availableSlots = [\n-        { id: 1, startTime: new Date('2023-01-01T09:00:00Z'), endTime: new Date('2023-01-01T10:00:00Z'), isBooked: false },\n-        { id: 2, startTime: new Date('2023-01-01T14:00:00Z'), endTime: new Date('2023-01-01T15:00:00Z'), isBooked: false },\n-      ];\n-      \n-      mockPrismaService.slot.findMany.mockResolvedValue(availableSlots);\n-      \n-      const result = await service.findAvailable(startDate, endDate);\n-      \n-      expect(mockPrismaService.slot.findMany).toHaveBeenCalledWith({\n-        where: {\n-          startTime: { gte: startDate },\n-          endTime: { lte: endDate },\n-          isBooked: false,\n-        },\n-      });\n-      expect(result).toEqual(availableSlots);\n-    });\n-  });\n-\n-  describe('findOne', () => {\n-    it('should return a slot by id', async () => {\n-      const id = 1;\n-      const slot = { id, startTime: new Date(), endTime: new Date(), isBooked: false };\n-      \n-      mockPrismaService.slot.findUnique.mockResolvedValue(slot);\n-      \n-      const result = await service.findOne(id);\n-      \n-      expect(mockPrismaService.slot.findUnique).toHaveBeenCalledWith({\n-        where: { id },\n-      });\n-      expect(result).toEqual(slot);\n-    });\n-\n-    it('should throw NotFoundException if slot is not found', async () => {\n-      const id = 999;\n-      \n-      mockPrismaService.slot.findUnique.mockResolvedValue(null);\n-      \n-      await expect(service.findOne(id)).rejects.toThrow(NotFoundException);\n-    });\n-  });\n-\n-  describe('update', () => {\n-    it('should update a slot successfully', async () => {\n-      const id = 1;\n-      const updateSlotDto: UpdateSlotDto = { isBooked: true };\n-      const existingSlot = { \n-        id, \n-        startTime: new Date('2023-01-01T09:00:00Z'), \n-        endTime: new Date('2023-01-01T10:00:00Z'), \n-        isBooked: false \n-      };\n-      const updatedSlot = { ...existingSlot, ...updateSlotDto };\n-      \n-      mockPrismaService.slot.findUnique.mockResolvedValue(existingSlot);\n-      mockPrismaService.slot.update.mockResolvedValue(updatedSlot);\n-      \n-      const result = await service.update(id, updateSlotDto);\n-      \n-      expect(mockPrismaService.slot.findUnique).toHaveBeenCalledWith({\n-        where: { id },\n-      });\n-      expect(mockPrismaService.slot.update).toHaveBeenCalledWith({\n-        where: { id },\n-        data: updateSlotDto,\n-      });\n-      expect(result).toEqual(updatedSlot);\n-    });\n-\n-    it('should throw NotFoundException if slot to update is not found', async () => {\n-      const id = 999;\n-      const updateSlotDto: UpdateSlotDto = { isBooked: true };\n-      \n-      mockPrismaService.slot.findUnique.mockResolvedValue(null);\n-      \n-      await expect(service.update(id, updateSlotDto)).rejects.toThrow(NotFoundException);\n-    });\n-\n-    it('should throw BadRequestException if trying to update with invalid time range', async () => {\n-      const id = 1;\n-      const existingSlot = { \n-        id, \n-        startTime: new Date('2023-01-01T09:00:00Z'), \n-        endTime: new Date('2023-01-01T10:00:00Z'), \n-        isBooked: false \n-      };\n-      const updateSlotDto: UpdateSlotDto = { \n-        startTime: new Date('2023-01-01T11:00:00Z'),\n-        endTime: new Date('2023-01-01T10:00:00Z')\n-      };\n-      \n-      mockPrismaService.slot.findUnique.mockResolvedValue(existingSlot);\n-      \n-      await expect(service.update(id, updateSlotDto)).rejects.toThrow(BadRequestException);\n-    });\n-  });\n-\n-  describe('remove', () => {\n-    it('should remove a slot successfully', async () => {\n-      const id = 1;\n-      const slot = { id, startTime: new Date(), endTime: new Date(), isBooked: false };\n-      \n-      mockPrismaService.slot.findUnique.mockResolvedValue(slot);\n-      mockPrismaService.slot.delete.mockResolvedValue(slot);\n-      \n-      await service.remove(id);\n-      \n-      expect(mockPrismaService.slot.findUnique).toHaveBeenCalledWith({\n-        where: { id },\n-      });\n-      expect(mockPrismaService.slot.delete).toHaveBeenCalledWith({\n-        where: { id },\n-      });\n-    });\n-\n-    it('should throw NotFoundException if slot to remove is not found', async () => {\n-      const id = 999;\n-      \n-      mockPrismaService.slot.findUnique.mockResolvedValue(null);\n-      \n-      await expect(service.remove(id)).rejects.toThrow(NotFoundException);\n-    });\n-  });\n-\n-  describe('findBookedSlots', () => {\n-    it('should return booked slots for a given user', async () => {\n-      const userId = 3;\n-      \n-      const bookedSlots = [\n-        { \n-          id: 1, \n-          sales_manager_id: 104,\n-          start_date: new Date('2024-05-03T10:30:00.000Z'),\n-          end_date: new Date('2024-05-03T11:00:00.000Z'),\n-          user_id: userId\n-        }\n-      ];\n-      \n-      mockPrismaService.slot.findMany.mockResolvedValue(bookedSlots);\n-      \n-      const result = await service.findBookedSlots(userId);\n-      \n-      expect(mockPrismaService.slot.findMany).toHaveBeenCalledWith({\n-        where: {\n-          user_id: userId,\n-          isBooked: true,\n-        },\n-      });\n-      expect(result).toEqual(bookedSlots);\n-    });\n-  });\n-});\n"
                },
                {
                    "date": 1740695161617,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,12 @@\n+import { Test, TestingModule } from '@nestjs/testing';\n+import { SlotService } from './slot.service';\n+import { PrismaService } from '../common/prisma/prisma.service';\n+import { NotFoundException, BadRequestException } from '@nestjs/common';\n+import { BookedSlotDto } from './dto/booked-slot.dto';\n+import { SlotBookingsDto } from './dto/slot-bookings.dto';\n+\n+describe('SlotService', () => {\n+  let service: SlotService;\n+  let prisma: PrismaService;\n+\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740695232783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,14 +9,4 @@\n   let service: SlotService;\n   let prisma: PrismaService;\n \n }\n-import { Test, TestingModule } from '@nestjs/testing';\n-import { SlotService } from './slot.service';\n-import { PrismaService } from '../common/prisma/prisma.service';\n-import { NotFoundException, BadRequestException } from '@nestjs/common';\n-import { BookedSlotDto } from './dto/booked-slot.dto';\n-import { SlotBookingsDto } from './dto/slot-bookings.dto';\n-\n-describe('SlotService', () => {\n-  let service: SlotService;\n-  let prisma: PrismaService;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740695238493,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,5 +8,5 @@\n describe('SlotService', () => {\n   let service: SlotService;\n   let prisma: PrismaService;\n \n-}\n+})\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740696441415,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,5 +8,163 @@\n describe('SlotService', () => {\n   let service: SlotService;\n   let prisma: PrismaService;\n \n-})\n\\ No newline at end of file\n+  const mockPrismaService = {\n+    $transaction: jest.fn(),\n+    slot: {\n+      update: jest.fn(),\n+    },\n+    $queryRawUnsafe: jest.fn(),\n+  };\n+\n+  beforeEach(async () => {\n+    const module: TestingModule = await Test.createTestingModule({\n+      providers: [\n+        SlotService,\n+        {\n+          provide: PrismaService,\n+          useValue: mockPrismaService,\n+        },\n+      ],\n+    }).compile();\n+\n+    service = module.get<SlotService>(SlotService);\n+    prisma = module.get<PrismaService>(PrismaService);\n+    \n+    jest.clearAllMocks();\n+  });\n+\n+  describe('bookSlot', () => {\n+    it('should successfully book an available slot', async () => {\n+      // Arrange\n+      const slotBookingsDto: SlotBookingsDto = {\n+        slotIds: [1],\n+        userId: 3,\n+      };\n+      \n+      const availableSlot = [{ id: 1 }];\n+      const bookedSlot: BookedSlotDto = {\n+        id: 1,\n+        sales_manager_id: 104,\n+        start_date: new Date('2024-05-03T10:30:00.000Z'),\n+        end_date: new Date('2024-05-03T11:00:00.000Z'),\n+        user_id: 3,\n+      };\n+\n+      // Mock the transaction callback execution\n+      mockPrismaService.$transaction.mockImplementation(async (callback) => {\n+        const tx = {\n+          $queryRawUnsafe: jest.fn().mockResolvedValue(availableSlot),\n+          slot: {\n+            update: jest.fn().mockResolvedValue(bookedSlot),\n+          },\n+        };\n+        return callback(tx);\n+      });\n+\n+      // Act\n+      const result = await service.bookSlot(slotBookingsDto);\n+\n+      // Assert\n+      expect(mockPrismaService.$transaction).toHaveBeenCalled();\n+      expect(result).toEqual(bookedSlot);\n+    });\n+\n+    it('should try multiple slots until finding an available one', async () => {\n+      // Arrange\n+      const slotBookingsDto: SlotBookingsDto = {\n+        slotIds: [1, 2, 3],\n+        userId: 3,\n+      };\n+      \n+      const bookedSlot: BookedSlotDto = {\n+        id: 2,\n+        sales_manager_id: 104,\n+        start_date: new Date('2024-05-03T10:30:00.000Z'),\n+        end_date: new Date('2024-05-03T11:00:00.000Z'),\n+        user_id: 3,\n+      };\n+\n+      // Mock the transaction callback execution\n+      mockPrismaService.$transaction.mockImplementation(async (callback) => {\n+        const tx = {\n+          $queryRawUnsafe: jest.fn()\n+            .mockResolvedValueOnce([]) // First slot not available\n+            .mockResolvedValueOnce([{ id: 2 }]), // Second slot available\n+          slot: {\n+            update: jest.fn().mockResolvedValue(bookedSlot),\n+          },\n+        };\n+        return callback(tx);\n+      });\n+\n+      // Act\n+      const result = await service.bookSlot(slotBookingsDto);\n+\n+      // Assert\n+      expect(mockPrismaService.$transaction).toHaveBeenCalled();\n+      expect(result).toEqual(bookedSlot);\n+    });\n+\n+    it('should throw NotFoundException when no slots are available', async () => {\n+      // Arrange\n+      const slotBookingsDto: SlotBookingsDto = {\n+        slotIds: [1, 2],\n+        userId: 3,\n+      };\n+\n+      // Mock the transaction callback execution\n+      mockPrismaService.$transaction.mockImplementation(async (callback) => {\n+        const tx = {\n+          $queryRawUnsafe: jest.fn().mockResolvedValue([]), // No slots available\n+          slot: {\n+            update: jest.fn(),\n+          },\n+        };\n+        return callback(tx);\n+      });\n+\n+      // Act & Assert\n+      await expect(service.bookSlot(slotBookingsDto)).rejects.toThrow(\n+        NotFoundException,\n+      );\n+    });\n+\n+    it('should catch and rethrow errors as BadRequestException', async () => {\n+      // Arrange\n+      const slotBookingsDto: SlotBookingsDto = {\n+        slotIds: [1],\n+        userId: 3,\n+      };\n+\n+      const errorMessage = 'Database error';\n+      mockPrismaService.$transaction.mockRejectedValue(new Error(errorMessage));\n+\n+      // Act & Assert\n+      await expect(service.bookSlot(slotBookingsDto)).rejects.toThrow(\n+        BadRequestException,\n+      );\n+      await expect(service.bookSlot(slotBookingsDto)).rejects.toThrow(\n+        errorMessage,\n+      );\n+    });\n+\n+    it('should handle non-Error exceptions and provide a generic message', async () => {\n+      // Arrange\n+      const slotBookingsDto: SlotBookingsDto = {\n+        slotIds: [1],\n+        userId: 3,\n+      };\n+\n+      mockPrismaService.$transaction.mockRejectedValue('Some non-error exception');\n+\n+      // Act & Assert\n+      await expect(service.bookSlot(slotBookingsDto)).rejects.toThrow(\n+        BadRequestException,\n+      );\n+      await expect(service.bookSlot(slotBookingsDto)).rejects.toThrow(\n+        'Error booking slot',\n+      );\n+    });\n+  });\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1740698809552,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,8 @@\n import { SlotBookingsDto } from './dto/slot-bookings.dto';\n \n describe('SlotService', () => {\n   let service: SlotService;\n-  let prisma: PrismaService;\n \n   const mockPrismaService = {\n     $transaction: jest.fn(),\n     slot: {\n@@ -28,10 +27,9 @@\n       ],\n     }).compile();\n \n     service = module.get<SlotService>(SlotService);\n-    prisma = module.get<PrismaService>(PrismaService);\n-    \n+\n     jest.clearAllMocks();\n   });\n \n   describe('bookSlot', () => {\n@@ -40,9 +38,9 @@\n       const slotBookingsDto: SlotBookingsDto = {\n         slotIds: [1],\n         userId: 3,\n       };\n-      \n+\n       const availableSlot = [{ id: 1 }];\n       const bookedSlot: BookedSlotDto = {\n         id: 1,\n         sales_manager_id: 104,\n@@ -50,9 +48,9 @@\n         end_date: new Date('2024-05-03T11:00:00.000Z'),\n         user_id: 3,\n       };\n \n-      // Mock the transaction callback execution\n+      mockPrismaService.$transaction.mockImplementation((callback) => {\n       mockPrismaService.$transaction.mockImplementation(async (callback) => {\n         const tx = {\n           $queryRawUnsafe: jest.fn().mockResolvedValue(availableSlot),\n           slot: {\n@@ -61,12 +59,10 @@\n         };\n         return callback(tx);\n       });\n \n-      // Act\n       const result = await service.bookSlot(slotBookingsDto);\n \n-      // Assert\n       expect(mockPrismaService.$transaction).toHaveBeenCalled();\n       expect(result).toEqual(bookedSlot);\n     });\n \n@@ -75,46 +71,42 @@\n       const slotBookingsDto: SlotBookingsDto = {\n         slotIds: [1, 2, 3],\n         userId: 3,\n       };\n-      \n+\n       const bookedSlot: BookedSlotDto = {\n         id: 2,\n         sales_manager_id: 104,\n         start_date: new Date('2024-05-03T10:30:00.000Z'),\n         end_date: new Date('2024-05-03T11:00:00.000Z'),\n         user_id: 3,\n       };\n \n-      // Mock the transaction callback execution\n       mockPrismaService.$transaction.mockImplementation(async (callback) => {\n         const tx = {\n-          $queryRawUnsafe: jest.fn()\n-            .mockResolvedValueOnce([]) // First slot not available\n-            .mockResolvedValueOnce([{ id: 2 }]), // Second slot available\n+          $queryRawUnsafe: jest\n+            .fn()\n+            .mockResolvedValueOnce([])\n+            .mockResolvedValueOnce([{ id: 2 }]),\n           slot: {\n             update: jest.fn().mockResolvedValue(bookedSlot),\n           },\n         };\n         return callback(tx);\n       });\n \n-      // Act\n       const result = await service.bookSlot(slotBookingsDto);\n \n-      // Assert\n       expect(mockPrismaService.$transaction).toHaveBeenCalled();\n       expect(result).toEqual(bookedSlot);\n     });\n \n     it('should throw NotFoundException when no slots are available', async () => {\n-      // Arrange\n       const slotBookingsDto: SlotBookingsDto = {\n         slotIds: [1, 2],\n         userId: 3,\n       };\n \n-      // Mock the transaction callback execution\n       mockPrismaService.$transaction.mockImplementation(async (callback) => {\n         const tx = {\n           $queryRawUnsafe: jest.fn().mockResolvedValue([]), // No slots available\n           slot: {\n@@ -123,16 +115,14 @@\n         };\n         return callback(tx);\n       });\n \n-      // Act & Assert\n       await expect(service.bookSlot(slotBookingsDto)).rejects.toThrow(\n         NotFoundException,\n       );\n     });\n \n     it('should catch and rethrow errors as BadRequestException', async () => {\n-      // Arrange\n       const slotBookingsDto: SlotBookingsDto = {\n         slotIds: [1],\n         userId: 3,\n       };\n@@ -149,22 +139,22 @@\n       );\n     });\n \n     it('should handle non-Error exceptions and provide a generic message', async () => {\n-      // Arrange\n       const slotBookingsDto: SlotBookingsDto = {\n         slotIds: [1],\n         userId: 3,\n       };\n \n-      mockPrismaService.$transaction.mockRejectedValue('Some non-error exception');\n+      mockPrismaService.$transaction.mockRejectedValue(\n+        'Some non-error exception',\n+      );\n \n-      // Act & Assert\n       await expect(service.bookSlot(slotBookingsDto)).rejects.toThrow(\n         BadRequestException,\n       );\n       await expect(service.bookSlot(slotBookingsDto)).rejects.toThrow(\n         'Error booking slot',\n       );\n\\ No newline at end of file\n     });\n   });\n-});\n+});\n"
                },
                {
                    "date": 1740698873705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,8 @@\n         user_id: 3,\n       };\n \n       mockPrismaService.$transaction.mockImplementation((callback) => {\n-      mockPrismaService.$transaction.mockImplementation(async (callback) => {\n         const tx = {\n           $queryRawUnsafe: jest.fn().mockResolvedValue(availableSlot),\n           slot: {\n             update: jest.fn().mockResolvedValue(bookedSlot),\n@@ -80,9 +79,9 @@\n         end_date: new Date('2024-05-03T11:00:00.000Z'),\n         user_id: 3,\n       };\n \n-      mockPrismaService.$transaction.mockImplementation(async (callback) => {\n+      mockPrismaService.$transaction.mockImplementation((callback) => {\n         const tx = {\n           $queryRawUnsafe: jest\n             .fn()\n             .mockResolvedValueOnce([])\n@@ -105,9 +104,9 @@\n         slotIds: [1, 2],\n         userId: 3,\n       };\n \n-      mockPrismaService.$transaction.mockImplementation(async (callback) => {\n+      mockPrismaService.$transaction.mockImplementation((callback) => {\n         const tx = {\n           $queryRawUnsafe: jest.fn().mockResolvedValue([]), // No slots available\n           slot: {\n             update: jest.fn(),\n@@ -156,5 +155,5 @@\n         'Error booking slot',\n       );\n     });\n   });\n-});\n\\ No newline at end of file\n+});\n"
                },
                {
                    "date": 1740698989238,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n         end_date: new Date('2024-05-03T11:00:00.000Z'),\n         user_id: 3,\n       };\n \n-      mockPrismaService.$transaction.mockImplementation((callback) => {\n+      mockPrismaService.$transaction.mockImplementation(<T>(callback: (tx: any) => Promise<T>) => {\n         const tx = {\n           $queryRawUnsafe: jest.fn().mockResolvedValue(availableSlot),\n           slot: {\n             update: jest.fn().mockResolvedValue(bookedSlot),\n@@ -79,9 +79,9 @@\n         end_date: new Date('2024-05-03T11:00:00.000Z'),\n         user_id: 3,\n       };\n \n-      mockPrismaService.$transaction.mockImplementation((callback) => {\n+      mockPrismaService.$transaction.mockImplementation(<T>(callback: (tx: any) => Promise<T>) => {\n         const tx = {\n           $queryRawUnsafe: jest\n             .fn()\n             .mockResolvedValueOnce([])\n@@ -104,9 +104,9 @@\n         slotIds: [1, 2],\n         userId: 3,\n       };\n \n-      mockPrismaService.$transaction.mockImplementation((callback) => {\n+      mockPrismaService.$transaction.mockImplementation(<T>(callback: (tx: any) => Promise<T>) => {\n         const tx = {\n           $queryRawUnsafe: jest.fn().mockResolvedValue([]), // No slots available\n           slot: {\n             update: jest.fn(),\n"
                },
                {
                    "date": 1740699002081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,17 +48,19 @@\n         end_date: new Date('2024-05-03T11:00:00.000Z'),\n         user_id: 3,\n       };\n \n-      mockPrismaService.$transaction.mockImplementation(<T>(callback: (tx: any) => Promise<T>) => {\n-        const tx = {\n-          $queryRawUnsafe: jest.fn().mockResolvedValue(availableSlot),\n-          slot: {\n-            update: jest.fn().mockResolvedValue(bookedSlot),\n-          },\n-        };\n-        return callback(tx);\n-      });\n+      mockPrismaService.$transaction.mockImplementation(\n+        <T>(callback: (tx: any) => Promise<T>) => {\n+          const tx = {\n+            $queryRawUnsafe: jest.fn().mockResolvedValue(availableSlot),\n+            slot: {\n+              update: jest.fn().mockResolvedValue(bookedSlot),\n+            },\n+          };\n+          return callback(tx);\n+        },\n+      );\n \n       const result = await service.bookSlot(slotBookingsDto);\n \n       expect(mockPrismaService.$transaction).toHaveBeenCalled();\n@@ -79,20 +81,22 @@\n         end_date: new Date('2024-05-03T11:00:00.000Z'),\n         user_id: 3,\n       };\n \n-      mockPrismaService.$transaction.mockImplementation(<T>(callback: (tx: any) => Promise<T>) => {\n-        const tx = {\n-          $queryRawUnsafe: jest\n-            .fn()\n-            .mockResolvedValueOnce([])\n-            .mockResolvedValueOnce([{ id: 2 }]),\n-          slot: {\n-            update: jest.fn().mockResolvedValue(bookedSlot),\n-          },\n-        };\n-        return callback(tx);\n-      });\n+      mockPrismaService.$transaction.mockImplementation(\n+        <T>(callback: (tx: any) => Promise<T>) => {\n+          const tx = {\n+            $queryRawUnsafe: jest\n+              .fn()\n+              .mockResolvedValueOnce([])\n+              .mockResolvedValueOnce([{ id: 2 }]),\n+            slot: {\n+              update: jest.fn().mockResolvedValue(bookedSlot),\n+            },\n+          };\n+          return callback(tx);\n+        },\n+      );\n \n       const result = await service.bookSlot(slotBookingsDto);\n \n       expect(mockPrismaService.$transaction).toHaveBeenCalled();\n@@ -104,17 +108,19 @@\n         slotIds: [1, 2],\n         userId: 3,\n       };\n \n-      mockPrismaService.$transaction.mockImplementation(<T>(callback: (tx: any) => Promise<T>) => {\n-        const tx = {\n-          $queryRawUnsafe: jest.fn().mockResolvedValue([]), // No slots available\n-          slot: {\n-            update: jest.fn(),\n-          },\n-        };\n-        return callback(tx);\n-      });\n+      mockPrismaService.$transaction.mockImplementation(\n+        <T>(callback: (tx: any) => Promise<T>) => {\n+          const tx = {\n+            $queryRawUnsafe: jest.fn().mockResolvedValue([]), // No slots available\n+            slot: {\n+              update: jest.fn(),\n+            },\n+          };\n+          return callback(tx);\n+        },\n+      );\n \n       await expect(service.bookSlot(slotBookingsDto)).rejects.toThrow(\n         NotFoundException,\n       );\n"
                },
                {
                    "date": 1740699012180,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -132,9 +132,11 @@\n         userId: 3,\n       };\n \n       const errorMessage = 'Database error';\n-      mockPrismaService.$transaction.mockRejectedValue(new Error(errorMessage));\n+      mockPrismaService.$transaction.mockRejectedValue(\n+        new BadRequestException(errorMessage)\n+      );\n \n       // Act & Assert\n       await expect(service.bookSlot(slotBookingsDto)).rejects.toThrow(\n         BadRequestException,\n@@ -150,9 +152,9 @@\n         userId: 3,\n       };\n \n       mockPrismaService.$transaction.mockRejectedValue(\n-        'Some non-error exception',\n+        new BadRequestException('Error booking slot')\n       );\n \n       await expect(service.bookSlot(slotBookingsDto)).rejects.toThrow(\n         BadRequestException,\n"
                },
                {
                    "date": 1740699019059,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -133,9 +133,9 @@\n       };\n \n       const errorMessage = 'Database error';\n       mockPrismaService.$transaction.mockRejectedValue(\n-        new BadRequestException(errorMessage)\n+        new BadRequestException(errorMessage),\n       );\n \n       // Act & Assert\n       await expect(service.bookSlot(slotBookingsDto)).rejects.toThrow(\n@@ -152,9 +152,9 @@\n         userId: 3,\n       };\n \n       mockPrismaService.$transaction.mockRejectedValue(\n-        new BadRequestException('Error booking slot')\n+        new BadRequestException('Error booking slot'),\n       );\n \n       await expect(service.bookSlot(slotBookingsDto)).rejects.toThrow(\n         BadRequestException,\n"
                }
            ],
            "date": 1740690870910,
            "name": "Commit-0",
            "content": "import { Test, TestingModule } from '@nestjs/testing';\nimport { SlotService } from './slot.service';\nimport { getRepositoryToken } from '@nestjs/typeorm';\nimport { Slot } from './entities/slot.entity';\nimport { Repository } from 'typeorm';\nimport { NotFoundException, BadRequestException } from '@nestjs/common';\nimport { CreateSlotDto } from './dto/create-slot.dto';\nimport { UpdateSlotDto } from './dto/update-slot.dto';\n\ndescribe('SlotService', () => {\n  let service: SlotService;\n  let repository: Repository<Slot>;\n\n  const mockSlotRepository = {\n    create: jest.fn(),\n    save: jest.fn(),\n    find: jest.fn(),\n    findOne: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n    createQueryBuilder: jest.fn(() => ({\n      where: jest.fn().mockReturnThis(),\n      andWhere: jest.fn().mockReturnThis(),\n      getMany: jest.fn(),\n    })),\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        SlotService,\n        {\n          provide: getRepositoryToken(Slot),\n          useValue: mockSlotRepository,\n        },\n      ],\n    }).compile();\n\n    service = module.get<SlotService>(SlotService);\n    repository = module.get<Repository<Slot>>(getRepositoryToken(Slot));\n    \n    jest.clearAllMocks();\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n\n  describe('create', () => {\n    it('should create a new slot successfully', async () => {\n      const createSlotDto: CreateSlotDto = {\n        startTime: new Date('2023-01-01T09:00:00Z'),\n        endTime: new Date('2023-01-01T10:00:00Z'),\n        isBooked: false,\n      };\n      \n      const newSlot = { id: 1, ...createSlotDto };\n      \n      mockSlotRepository.create.mockReturnValue(newSlot);\n      mockSlotRepository.save.mockResolvedValue(newSlot);\n      \n      const result = await service.create(createSlotDto);\n      \n      expect(mockSlotRepository.create).toHaveBeenCalledWith(createSlotDto);\n      expect(mockSlotRepository.save).toHaveBeenCalledWith(newSlot);\n      expect(result).toEqual(newSlot);\n    });\n\n    it('should throw BadRequestException if end time is before start time', async () => {\n      const createSlotDto: CreateSlotDto = {\n        startTime: new Date('2023-01-01T10:00:00Z'),\n        endTime: new Date('2023-01-01T09:00:00Z'),\n        isBooked: false,\n      };\n      \n      await expect(service.create(createSlotDto)).rejects.toThrow(BadRequestException);\n    });\n\n    it('should throw BadRequestException if slot duration is invalid', async () => {\n      const createSlotDto: CreateSlotDto = {\n        startTime: new Date('2023-01-01T09:00:00Z'),\n        endTime: new Date('2023-01-01T09:15:00Z'), // Assuming minimum duration is 30 minutes\n        isBooked: false,\n      };\n      \n      await expect(service.create(createSlotDto)).rejects.toThrow(BadRequestException);\n    });\n  });\n\n  describe('findAll', () => {\n    it('should return an array of slots', async () => {\n      const slots = [\n        { id: 1, startTime: new Date(), endTime: new Date(), isBooked: false },\n        { id: 2, startTime: new Date(), endTime: new Date(), isBooked: true },\n      ];\n      \n      mockSlotRepository.find.mockResolvedValue(slots);\n      \n      const result = await service.findAll();\n      \n      expect(mockSlotRepository.find).toHaveBeenCalled();\n      expect(result).toEqual(slots);\n    });\n  });\n\n  describe('findAvailable', () => {\n    it('should return available slots for a given date range', async () => {\n      const startDate = new Date('2023-01-01');\n      const endDate = new Date('2023-01-02');\n      \n      const availableSlots = [\n        { id: 1, startTime: new Date('2023-01-01T09:00:00Z'), endTime: new Date('2023-01-01T10:00:00Z'), isBooked: false },\n        { id: 2, startTime: new Date('2023-01-01T14:00:00Z'), endTime: new Date('2023-01-01T15:00:00Z'), isBooked: false },\n      ];\n      \n      const queryBuilder = mockSlotRepository.createQueryBuilder();\n      queryBuilder.getMany.mockResolvedValue(availableSlots);\n      \n      const result = await service.findAvailable(startDate, endDate);\n      \n      expect(mockSlotRepository.createQueryBuilder).toHaveBeenCalled();\n      expect(queryBuilder.where).toHaveBeenCalledWith('slot.startTime >= :startDate', { startDate });\n      expect(queryBuilder.andWhere).toHaveBeenCalledWith('slot.endTime <= :endDate', { endDate });\n      expect(queryBuilder.andWhere).toHaveBeenCalledWith('slot.isBooked = :isBooked', { isBooked: false });\n      expect(result).toEqual(availableSlots);\n    });\n  });\n\n  describe('findOne', () => {\n    it('should return a slot by id', async () => {\n      const id = 1;\n      const slot = { id, startTime: new Date(), endTime: new Date(), isBooked: false };\n      \n      mockSlotRepository.findOne.mockResolvedValue(slot);\n      \n      const result = await service.findOne(id);\n      \n      expect(mockSlotRepository.findOne).toHaveBeenCalledWith({ where: { id } });\n      expect(result).toEqual(slot);\n    });\n\n    it('should throw NotFoundException if slot is not found', async () => {\n      const id = 999;\n      \n      mockSlotRepository.findOne.mockResolvedValue(null);\n      \n      await expect(service.findOne(id)).rejects.toThrow(NotFoundException);\n    });\n  });\n\n  describe('update', () => {\n    it('should update a slot successfully', async () => {\n      const id = 1;\n      const updateSlotDto: UpdateSlotDto = { isBooked: true };\n      const existingSlot = { \n        id, \n        startTime: new Date('2023-01-01T09:00:00Z'), \n        endTime: new Date('2023-01-01T10:00:00Z'), \n        isBooked: false \n      };\n      const updatedSlot = { ...existingSlot, ...updateSlotDto };\n      \n      mockSlotRepository.findOne.mockResolvedValue(existingSlot);\n      mockSlotRepository.update.mockResolvedValue({ affected: 1 });\n      mockSlotRepository.findOne.mockResolvedValueOnce(existingSlot).mockResolvedValueOnce(updatedSlot);\n      \n      const result = await service.update(id, updateSlotDto);\n      \n      expect(mockSlotRepository.findOne).toHaveBeenCalledWith({ where: { id } });\n      expect(mockSlotRepository.update).toHaveBeenCalledWith(id, updateSlotDto);\n      expect(result).toEqual(updatedSlot);\n    });\n\n    it('should throw NotFoundException if slot to update is not found', async () => {\n      const id = 999;\n      const updateSlotDto: UpdateSlotDto = { isBooked: true };\n      \n      mockSlotRepository.findOne.mockResolvedValue(null);\n      \n      await expect(service.update(id, updateSlotDto)).rejects.toThrow(NotFoundException);\n    });\n\n    it('should throw BadRequestException if trying to update with invalid time range', async () => {\n      const id = 1;\n      const existingSlot = { \n        id, \n        startTime: new Date('2023-01-01T09:00:00Z'), \n        endTime: new Date('2023-01-01T10:00:00Z'), \n        isBooked: false \n      };\n      const updateSlotDto: UpdateSlotDto = { \n        startTime: new Date('2023-01-01T11:00:00Z'),\n        endTime: new Date('2023-01-01T10:00:00Z')\n      };\n      \n      mockSlotRepository.findOne.mockResolvedValue(existingSlot);\n      \n      await expect(service.update(id, updateSlotDto)).rejects.toThrow(BadRequestException);\n    });\n  });\n\n  describe('remove', () => {\n    it('should remove a slot successfully', async () => {\n      const id = 1;\n      const slot = { id, startTime: new Date(), endTime: new Date(), isBooked: false };\n      \n      mockSlotRepository.findOne.mockResolvedValue(slot);\n      mockSlotRepository.delete.mockResolvedValue({ affected: 1 });\n      \n      await service.remove(id);\n      \n      expect(mockSlotRepository.findOne).toHaveBeenCalledWith({ where: { id } });\n      expect(mockSlotRepository.delete).toHaveBeenCalledWith(id);\n    });\n\n    it('should throw NotFoundException if slot to remove is not found', async () => {\n      const id = 999;\n      \n      mockSlotRepository.findOne.mockResolvedValue(null);\n      \n      await expect(service.remove(id)).rejects.toThrow(NotFoundException);\n    });\n  });\n});\n"
        }
    ]
}